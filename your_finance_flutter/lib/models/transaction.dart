import 'package:uuid/uuid.dart';
import 'package:equatable/equatable.dart';

// 交易类型枚举
enum TransactionType {
  income('收入'),
  expense('支出'),
  transfer('转账');

  const TransactionType(this.displayName);
  final String displayName;

  static TransactionType fromDisplayName(String displayName) {
    return TransactionType.values.firstWhere(
      (e) => e.displayName == displayName,
      orElse: () => throw ArgumentError('Unknown TransactionType: $displayName'),
    );
  }
}

// 交易状态枚举
enum TransactionStatus {
  draft('草稿'),
  confirmed('已确认'),
  pending('待处理'),
  cancelled('已取消');

  const TransactionStatus(this.displayName);
  final String displayName;

  static TransactionStatus fromDisplayName(String displayName) {
    return TransactionStatus.values.firstWhere(
      (e) => e.displayName == displayName,
      orElse: () => throw ArgumentError('Unknown TransactionStatus: $displayName'),
    );
  }
}

// 交易分类枚举
enum TransactionCategory {
  // 收入分类
  salary('工资'),
  bonus('奖金'),
  investment('投资收益'),
  freelance('自由职业'),
  gift('礼金'),
  otherIncome('其他收入'),

  // 支出分类
  food('餐饮'),
  transport('交通'),
  shopping('购物'),
  entertainment('娱乐'),
  healthcare('医疗'),
  education('教育'),
  housing('住房'),
  utilities('水电费'),
  insurance('保险'),
  otherExpense('其他支出');

  const TransactionCategory(this.displayName);
  final String displayName;

  static TransactionCategory fromDisplayName(String displayName) {
    return TransactionCategory.values.firstWhere(
      (e) => e.displayName == displayName,
      orElse: () => throw ArgumentError('Unknown TransactionCategory: $displayName'),
    );
  }

  // 判断是否为收入分类
  bool get isIncome {
    return [
      TransactionCategory.salary,
      TransactionCategory.bonus,
      TransactionCategory.investment,
      TransactionCategory.freelance,
      TransactionCategory.gift,
      TransactionCategory.otherIncome,
    ].contains(this);
  }

  // 判断是否为支出分类
  bool get isExpense {
    return [
      TransactionCategory.food,
      TransactionCategory.transport,
      TransactionCategory.shopping,
      TransactionCategory.entertainment,
      TransactionCategory.healthcare,
      TransactionCategory.education,
      TransactionCategory.housing,
      TransactionCategory.utilities,
      TransactionCategory.insurance,
      TransactionCategory.otherExpense,
    ].contains(this);
  }
}

// 交易记录模型
class Transaction extends Equatable {
  final String id;
  final String description;
  final double amount;
  final TransactionType type;
  final TransactionCategory category;
  final String? subCategory;
  final String fromAccountId;
  final String? toAccountId; // 转账时使用
  final String? envelopeBudgetId; // 关联的信封预算ID
  final DateTime date;
  final String? notes;
  final List<String> tags;
  final TransactionStatus status;
  final bool isRecurring;
  final String? recurringRule; // 周期性规则
  final String? parentTransactionId; // 关联的父交易ID
  final DateTime creationDate;
  final DateTime updateDate;
  final String? imagePath; // 收据/发票图片路径
  final bool isAutoGenerated; // 是否自动生成

  Transaction({
    String? id,
    required this.description,
    required this.amount,
    required this.type,
    required this.category,
    this.subCategory,
    required this.fromAccountId,
    this.toAccountId,
    this.envelopeBudgetId,
    required this.date,
    this.notes,
    this.tags = const [],
    this.status = TransactionStatus.confirmed,
    this.isRecurring = false,
    this.recurringRule,
    this.parentTransactionId,
    DateTime? creationDate,
    DateTime? updateDate,
    this.imagePath,
    this.isAutoGenerated = false,
  })  : id = id ?? const Uuid().v4(),
        creationDate = creationDate ?? DateTime.now(),
        updateDate = updateDate ?? DateTime.now();

  // 复制并修改
  Transaction copyWith({
    String? id,
    String? description,
    double? amount,
    TransactionType? type,
    TransactionCategory? category,
    String? subCategory,
    String? fromAccountId,
    String? toAccountId,
    String? envelopeBudgetId,
    DateTime? date,
    String? notes,
    List<String>? tags,
    TransactionStatus? status,
    bool? isRecurring,
    String? recurringRule,
    String? parentTransactionId,
    DateTime? creationDate,
    DateTime? updateDate,
    String? imagePath,
    bool? isAutoGenerated,
  }) {
    return Transaction(
      id: id ?? this.id,
      description: description ?? this.description,
      amount: amount ?? this.amount,
      type: type ?? this.type,
      category: category ?? this.category,
      subCategory: subCategory ?? this.subCategory,
      fromAccountId: fromAccountId ?? this.fromAccountId,
      toAccountId: toAccountId ?? this.toAccountId,
      envelopeBudgetId: envelopeBudgetId ?? this.envelopeBudgetId,
      date: date ?? this.date,
      notes: notes ?? this.notes,
      tags: tags ?? this.tags,
      status: status ?? this.status,
      isRecurring: isRecurring ?? this.isRecurring,
      recurringRule: recurringRule ?? this.recurringRule,
      parentTransactionId: parentTransactionId ?? this.parentTransactionId,
      creationDate: creationDate ?? this.creationDate,
      updateDate: updateDate ?? DateTime.now(),
      imagePath: imagePath ?? this.imagePath,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
    );
  }

  // 序列化
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'description': description,
      'amount': amount,
      'type': type.name,
      'category': category.name,
      'subCategory': subCategory,
      'fromAccountId': fromAccountId,
      'toAccountId': toAccountId,
      'envelopeBudgetId': envelopeBudgetId,
      'date': date.toIso8601String(),
      'notes': notes,
      'tags': tags,
      'status': status.name,
      'isRecurring': isRecurring,
      'recurringRule': recurringRule,
      'parentTransactionId': parentTransactionId,
      'creationDate': creationDate.toIso8601String(),
      'updateDate': updateDate.toIso8601String(),
      'imagePath': imagePath,
      'isAutoGenerated': isAutoGenerated,
    };
  }

  // 反序列化
  factory Transaction.fromJson(Map<String, dynamic> json) {
    return Transaction(
      id: json['id'] as String,
      description: json['description'] as String,
      amount: json['amount'] as double,
      type: TransactionType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => throw ArgumentError('Unknown TransactionType: ${json['type']}'),
      ),
      category: TransactionCategory.values.firstWhere(
        (e) => e.name == json['category'],
        orElse: () => throw ArgumentError('Unknown TransactionCategory: ${json['category']}'),
      ),
      subCategory: json['subCategory'] as String?,
      fromAccountId: json['fromAccountId'] as String,
      toAccountId: json['toAccountId'] as String?,
      envelopeBudgetId: json['envelopeBudgetId'] as String?,
      date: DateTime.parse(json['date'] as String),
      notes: json['notes'] as String?,
      tags: List<String>.from(json['tags'] ?? []),
      status: TransactionStatus.values.firstWhere(
        (e) => e.name == json['status'],
        orElse: () => throw ArgumentError('Unknown TransactionStatus: ${json['status']}'),
      ),
      isRecurring: json['isRecurring'] as bool? ?? false,
      recurringRule: json['recurringRule'] as String?,
      parentTransactionId: json['parentTransactionId'] as String?,
      creationDate: DateTime.parse(json['creationDate'] as String),
      updateDate: DateTime.parse(json['updateDate'] as String),
      imagePath: json['imagePath'] as String?,
      isAutoGenerated: json['isAutoGenerated'] as bool? ?? false,
    );
  }

  @override
  List<Object?> get props => [
        id,
        description,
        amount,
        type,
        category,
        subCategory,
        fromAccountId,
        toAccountId,
        envelopeBudgetId,
        date,
        notes,
        tags,
        status,
        isRecurring,
        recurringRule,
        parentTransactionId,
        creationDate,
        updateDate,
        imagePath,
        isAutoGenerated,
      ];
}
