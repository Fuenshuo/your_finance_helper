import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:your_finance_flutter/core/utils/logger.dart';
import 'package:your_finance_flutter/core/models/account.dart';
import 'package:your_finance_flutter/core/models/transaction.dart';
import 'package:your_finance_flutter/core/providers/transaction_provider.dart';
import 'package:your_finance_flutter/core/services/loan_calculation_service.dart';
import 'package:your_finance_flutter/core/services/storage_service.dart';

class AccountProvider with ChangeNotifier {
  List<Account> _accounts = [];
  bool _isLoading = false;
  String? _error;
  late final StorageService _storageService;

  // Getters
  List<Account> get accounts => _accounts;
  List<Account> get activeAccounts =>
      _accounts.where((a) => a.status == AccountStatus.active).toList();
  List<Account> get assetAccounts => _accounts
      .where((a) => a.type.isAsset && a.status == AccountStatus.active)
      .toList();
  List<Account> get liabilityAccounts => _accounts
      .where((a) => a.type.isLiability && a.status == AccountStatus.active)
      .toList();
  List<Account> get loanAccounts => _accounts
      .where((a) => a.isLoanAccount && a.status == AccountStatus.active)
      .toList();
  bool get isLoading => _isLoading;
  String? get error => _error;

  // åˆå§‹åŒ–
  Future<void> initialize() async {
    _storageService = await StorageService.getInstance();
    await _loadAccounts();
  }

  // åŠ è½½è´¦æˆ·æ•°æ®
  Future<void> _loadAccounts() async {
    try {
      _isLoading = true;
      _error = null;
      notifyListeners();

      _accounts = await _storageService.loadAccounts();
    } catch (e) {
      _error = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // æ·»åŠ è´¦æˆ·
  Future<void> addAccount(Account account) async {
    try {
      // å¦‚æœè®¾ç½®ä¸ºé»˜è®¤è´¦æˆ·ï¼Œå…ˆå–æ¶ˆå…¶ä»–é»˜è®¤è´¦æˆ·
      if (account.isDefault) {
        _accounts = _accounts.map((a) => a.copyWith(isDefault: false)).toList();
      }

      _accounts.add(account);
      await _storageService.saveAccounts(_accounts);
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  // æ›´æ–°è´¦æˆ·
  Future<void> updateAccount(Account updatedAccount) async {
    try {
      final index = _accounts.indexWhere((a) => a.id == updatedAccount.id);
      if (index != -1) {
        // å¦‚æœè®¾ç½®ä¸ºé»˜è®¤è´¦æˆ·ï¼Œå…ˆå–æ¶ˆå…¶ä»–é»˜è®¤è´¦æˆ·
        if (updatedAccount.isDefault) {
          _accounts =
              _accounts.map((a) => a.copyWith(isDefault: false)).toList();
        }

        _accounts[index] = updatedAccount.copyWith(updateDate: DateTime.now());
        await _storageService.saveAccounts(_accounts);
        notifyListeners();
      }
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  // åˆ é™¤è´¦æˆ·
  Future<void> deleteAccount(String accountId) async {
    try {
      _accounts.removeWhere((a) => a.id == accountId);
      await _storageService.saveAccounts(_accounts);
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  // è®¡ç®—è´¦æˆ·å®æ—¶ä½™é¢ï¼ˆåŸºäºæ‰€æœ‰äº¤æ˜“ï¼‰
  double getAccountBalance(String accountId, List<Transaction> transactions) {
    // è¿‡æ»¤å‡ºæ‰€æœ‰ä¸è¯¥è´¦æˆ·ç›¸å…³çš„äº¤æ˜“
    final accountTransactions = transactions.where(
      (transaction) =>
          transaction.fromAccountId == accountId ||
          transaction.toAccountId == accountId,
    );

    // è®¡ç®—ä½™é¢å˜åŒ– - ä»äº¤æ˜“å†å²æ±‡æ€»
    var balance = 0.0;
    for (final transaction in accountTransactions) {
      if (transaction.fromAccountId == accountId) {
        // ä»è¿™ä¸ªè´¦æˆ·å‡ºå»çš„é’±ï¼ˆæ”¯å‡ºæˆ–è½¬å‡ºï¼‰
        balance -= transaction.amount;
      }
      if (transaction.toAccountId == accountId) {
        // è¿›å…¥è¿™ä¸ªè´¦æˆ·çš„é’±ï¼ˆæ”¶å…¥æˆ–è½¬å…¥ï¼‰
        balance += transaction.amount;
      }
    }

    return balance;
  }

  // è·å–è´¦æˆ·çš„åˆå§‹ä½™é¢ï¼ˆé€šè¿‡æŸ¥æ‰¾åˆå§‹åŒ–äº¤æ˜“ï¼‰
  double getAccountInitialBalance(
    String accountId,
    List<Transaction> transactions,
  ) {
    // æŸ¥æ‰¾è¯¥è´¦æˆ·çš„åˆå§‹åŒ–äº¤æ˜“
    final initTransaction = transactions.firstWhere(
      (transaction) =>
          transaction.toAccountId == accountId &&
          transaction.isAutoGenerated == true &&
          transaction.description == 'è´¦æˆ·åˆå§‹åŒ–',
      orElse: () => null as Transaction,
    );

    return initTransaction.amount ?? 0.0;
  }

  // æ•°æ®è¿ç§»ï¼šå°†ç°æœ‰è´¦æˆ·ä½™é¢è½¬æ¢ä¸ºåˆå§‹åŒ–äº¤æ˜“
  Future<void> migrateAccountBalancesToTransactions(
    TransactionProvider transactionProvider,
  ) async {
    Logger.debug('ğŸ”„ å¼€å§‹è¿ç§»è´¦æˆ·ä½™é¢åˆ°äº¤æ˜“è®°å½•...');

    for (final account in _accounts) {
      // å¦‚æœè´¦æˆ·æœ‰ä½™é¢ä¸”æ²¡æœ‰åˆå§‹ä½™é¢è®°å½•ï¼Œåˆ›å»ºåˆå§‹åŒ–äº¤æ˜“
      if (account.balance > 0 && account.initialBalance == 0) {
        Logger.debug('ğŸ“ ä¸ºè´¦æˆ· ${account.name} åˆ›å»ºåˆå§‹åŒ–äº¤æ˜“ï¼Œé‡‘é¢: ${account.balance}');

        // ä½¿ç”¨æ›´æ—©çš„æ—¥æœŸé¿å…è®¡å…¥å½“æœˆç»Ÿè®¡
        final initDate =
            account.creationDate.subtract(const Duration(days: 1)) ??
                DateTime.now().subtract(const Duration(days: 1));

        final initTransaction = Transaction(
          description: 'è´¦æˆ·åˆå§‹åŒ–',
          amount: account.balance,
          type: TransactionType.income,
          category: TransactionCategory.otherIncome,
          toAccountId: account.id,
          date: initDate, // ä½¿ç”¨åˆ›å»ºæ—¥æœŸå‰ä¸€å¤©
          notes: 'ç³»ç»Ÿè¿ç§»ï¼šè´¦æˆ·åˆå§‹ä½™é¢',
          isAutoGenerated: true,
        );

        await transactionProvider.addTransaction(initTransaction);

        // å°†è´¦æˆ·ä½™é¢æ¸…é›¶ï¼Œå› ä¸ºç°åœ¨å®Œå…¨é€šè¿‡äº¤æ˜“è®¡ç®—
        final updatedAccount = account.copyWith(balance: 0.0);
        await updateAccount(updatedAccount);

        Logger.debug('âœ… è´¦æˆ· ${account.name} åˆå§‹åŒ–å®Œæˆ');
      }
    }

    Logger.debug('âœ… è´¦æˆ·ä½™é¢è¿ç§»å®Œæˆ');
  }

  // åˆ›å»ºè´¦æˆ·åˆå§‹åŒ–äº¤æ˜“ï¼ˆå½“è®¾ç½®åˆå§‹ä½™é¢æ—¶ï¼‰
  Future<Transaction?> createAccountInitializationTransaction(
    String accountId,
    double initialBalance,
    TransactionProvider transactionProvider,
  ) async {
    if (initialBalance <= 0) return null;

    final account = getAccountById(accountId);
    if (account == null) return null;

    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨åˆå§‹åŒ–äº¤æ˜“
    final existingTransactions = transactionProvider.transactions
        .where(
          (t) =>
              t.toAccountId == accountId &&
              t.isAutoGenerated == true &&
              t.description == 'è´¦æˆ·åˆå§‹åŒ–',
        )
        .toList();

    if (existingTransactions.isNotEmpty) {
      Logger.debug('âš ï¸ è´¦æˆ· ${account.name} å·²ç»å­˜åœ¨åˆå§‹åŒ–äº¤æ˜“ï¼Œè·³è¿‡åˆ›å»º');
      return existingTransactions.first;
    }

    // åˆ›å»ºç‰¹æ®Šçš„åˆå§‹åŒ–äº¤æ˜“ï¼Œä½¿ç”¨æ›´æ—©çš„æ—¥æœŸé¿å…è®¡å…¥å½“æœˆç»Ÿè®¡
    final initDate = account.creationDate.subtract(const Duration(days: 1)) ??
        DateTime.now().subtract(const Duration(days: 1));

    final initTransaction = Transaction(
      description: 'è´¦æˆ·åˆå§‹åŒ–',
      amount: initialBalance,
      type: TransactionType.income,
      category: TransactionCategory.otherIncome,
      toAccountId: accountId,
      date: initDate, // ä½¿ç”¨åˆ›å»ºæ—¥æœŸå‰ä¸€å¤©ï¼Œé¿å…è®¡å…¥å½“æœˆæ”¶å…¥
      notes: 'è´¦æˆ·åˆå§‹ä½™é¢è®¾ç½®',
      isAutoGenerated: true, // æ ‡è®°ä¸ºè‡ªåŠ¨ç”Ÿæˆï¼Œä¸è®¡å…¥ç»Ÿè®¡
    );

    await transactionProvider.addTransaction(initTransaction);

    // è´¦æˆ·çš„initialBalanceä¿æŒä¸º0ï¼Œä½™é¢å®Œå…¨é€šè¿‡äº¤æ˜“è®¡ç®—
    // æ— éœ€æ›´æ–°è´¦æˆ·

    return initTransaction;
  }

  // ä¸å†ç›´æ¥æ›´æ–°è´¦æˆ·ä½™é¢ï¼Œè€Œæ˜¯é€šè¿‡äº¤æ˜“æ¥æ”¹å˜
  // è¿™ä¸ªæ–¹æ³•ä¿ç•™ç”¨äºå‘åå…¼å®¹ï¼Œä½†ä¸åº”è¯¥è¢«è°ƒç”¨
  @deprecated
  Future<void> updateAccountBalance(String accountId, double newBalance) async {
    // è¿™ä¸ªæ–¹æ³•ä¸åº”è¯¥è¢«ä½¿ç”¨ï¼Œä½™é¢åº”è¯¥é€šè¿‡äº¤æ˜“è‡ªåŠ¨è®¡ç®—
    Logger.debug('âš ï¸ è­¦å‘Š: ä¸åº”è¯¥ç›´æ¥è°ƒç”¨updateAccountBalanceï¼Œä½™é¢åº”è¯¥é€šè¿‡äº¤æ˜“è‡ªåŠ¨è®¡ç®—');
  }

  // æ ¹æ®IDè·å–è´¦æˆ·
  Account? getAccountById(String accountId) {
    try {
      return _accounts.firstWhere((a) => a.id == accountId);
    } catch (e) {
      return null;
    }
  }

  // è·å–é»˜è®¤è´¦æˆ·
  Account? getDefaultAccount() {
    try {
      return _accounts
          .firstWhere((a) => a.isDefault && a.status == AccountStatus.active);
    } catch (e) {
      return null;
    }
  }

  // æ ¹æ®ç±»å‹è·å–è´¦æˆ·
  List<Account> getAccountsByType(AccountType type) => _accounts
      .where((a) => a.type == type && a.status == AccountStatus.active)
      .toList();

  // è®¡ç®—æ€»èµ„äº§ï¼ˆéœ€è¦ä¼ å…¥äº¤æ˜“æ•°æ®ï¼‰
  double calculateTotalAssets(List<Transaction> transactions) =>
      assetAccounts.fold(
        0.0,
        (sum, account) => sum + getAccountBalance(account.id, transactions),
      );

  // è®¡ç®—æ€»è´Ÿå€ºï¼ˆä½¿ç”¨å®é™…è´Ÿå€ºä½™é¢ï¼Œéœ€è¦ä¼ å…¥äº¤æ˜“æ•°æ®ï¼‰
  double calculateTotalLiabilities(List<Transaction> transactions) =>
      liabilityAccounts.fold(
        0.0,
        (sum, account) => sum + getAccountBalance(account.id, transactions),
      );

  // è®¡ç®—å‡€èµ„äº§ï¼ˆéœ€è¦ä¼ å…¥äº¤æ˜“æ•°æ®ï¼‰
  double calculateNetWorth(List<Transaction> transactions) =>
      calculateTotalAssets(transactions) -
      calculateTotalLiabilities(transactions);

  // æŒ‰ç±»å‹ç»Ÿè®¡è´¦æˆ·
  Map<AccountType, List<Account>> getAccountsByTypeMap() {
    final typeMap = <AccountType, List<Account>>{};

    for (final type in AccountType.values) {
      typeMap[type] = getAccountsByType(type);
    }

    return typeMap;
  }

  // æŒ‰ç±»å‹ç»Ÿè®¡ä½™é¢
  Map<AccountType, double> getBalanceByType(List<Transaction> transactions) {
    final balanceMap = <AccountType, double>{};

    for (final type in AccountType.values) {
      final accounts = getAccountsByType(type);
      balanceMap[type] = accounts.fold(
        0.0,
        (sum, account) => sum + getAccountBalance(account.id, transactions),
      );
    }

    return balanceMap;
  }

  // æœç´¢è´¦æˆ·
  List<Account> searchAccounts(String query) {
    if (query.isEmpty) return _accounts;

    final lowercaseQuery = query.toLowerCase();
    return _accounts
        .where(
          (a) =>
              a.name.toLowerCase().contains(lowercaseQuery) ||
              a.type.displayName.toLowerCase().contains(lowercaseQuery) ||
              (a.bankName?.toLowerCase().contains(lowercaseQuery) ?? false) ||
              a.tags.any((tag) => tag.toLowerCase().contains(lowercaseQuery)),
        )
        .toList();
  }

  // æ ¼å¼åŒ–ä½™é¢
  String formatBalance(double balance, {String currency = 'CNY'}) {
    final formatter = NumberFormat.currency(locale: 'zh_CN', symbol: 'Â¥');
    return formatter.format(balance);
  }

  // è·å–è´¦æˆ·å›¾æ ‡
  String getAccountIcon(AccountType type) {
    switch (type) {
      case AccountType.cash:
        return 'money';
      case AccountType.bank:
        return 'account_balance';
      case AccountType.creditCard:
        return 'credit_card';
      case AccountType.investment:
        return 'trending_up';
      case AccountType.loan:
        return 'account_balance_wallet';
      case AccountType.asset:
        return 'home';
      case AccountType.liability:
        return 'warning';
    }
  }

  // è·å–è´¦æˆ·é¢œè‰²
  String getAccountColor(AccountType type) {
    switch (type) {
      case AccountType.cash:
        return '#4CAF50'; // ç»¿è‰²
      case AccountType.bank:
        return '#2196F3'; // è“è‰²
      case AccountType.creditCard:
        return '#FF9800'; // æ©™è‰²
      case AccountType.investment:
        return '#9C27B0'; // ç´«è‰²
      case AccountType.loan:
        return '#F44336'; // çº¢è‰²
      case AccountType.asset:
        return '#607D8B'; // è“ç°è‰²
      case AccountType.liability:
        return '#795548'; // æ£•è‰²
    }
  }

  // éªŒè¯è´¦æˆ·åç§°æ˜¯å¦å”¯ä¸€
  bool isAccountNameUnique(String name, {String? excludeId}) => !_accounts.any(
        (a) =>
            a.name.toLowerCase() == name.toLowerCase() &&
            (excludeId == null || a.id != excludeId),
      );

  // è·å–è´¦æˆ·ç»Ÿè®¡ä¿¡æ¯
  Map<String, dynamic> getAccountStatistics(List<Transaction> transactions) {
    final totalAccounts = _accounts.length;
    final activeAccounts =
        _accounts.where((a) => a.status == AccountStatus.active).length;
    final totalAssets = calculateTotalAssets(transactions);
    final totalLiabilities = calculateTotalLiabilities(transactions);
    final netWorth = calculateNetWorth(transactions);

    return {
      'totalAccounts': totalAccounts,
      'activeAccounts': activeAccounts,
      'totalAssets': totalAssets,
      'totalLiabilities': totalLiabilities,
      'netWorth': netWorth,
    };
  }

  // æ¸…é™¤é”™è¯¯
  void clearError() {
    _error = null;
    notifyListeners();
  }

  // åˆ·æ–°æ•°æ®
  Future<void> refresh() async {
    await _loadAccounts();
  }

  // è´·æ¬¾ç®¡ç†ç›¸å…³æ–¹æ³•

  /// æ›´æ–°è´·æ¬¾çš„è¿˜æ¬¾è®¡åˆ’
  Future<void> updateLoanPaymentSchedule(String accountId) async {
    try {
      final account = getAccountById(accountId);
      if (account == null || !account.isLoanAccount) return;

      final loanCalculationService = LoanCalculationService();
      final result = loanCalculationService.calculateLoanSchedule(account);

      final updatedAccount = account.copyWith(
        monthlyPayment: result.monthlyPayment,
        updateDate: DateTime.now(),
      );

      await updateAccount(updatedAccount);
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  /// è®°å½•è´·æ¬¾è¿˜æ¬¾
  Future<void> recordLoanPayment(String accountId, double paymentAmount) async {
    try {
      final account = getAccountById(accountId);
      if (account == null || !account.isLoanAccount) return;

      // è®¡ç®—è¿˜æ¬¾åçš„å‰©ä½™æœ¬é‡‘
      final newRemainingPrincipal =
          (account.remainingPrincipal ?? 0) - paymentAmount;

      final updatedAccount = account.copyWith(
        remainingPrincipal: newRemainingPrincipal.clamp(0, double.infinity),
        updateDate: DateTime.now(),
      );

      await updateAccount(updatedAccount);
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  /// è·å–è´·æ¬¾ç»Ÿè®¡ä¿¡æ¯
  Map<String, dynamic> getLoanStatistics() {
    final loanAccounts = this.loanAccounts;
    final totalLoanAmount = loanAccounts.fold(
      0.0,
      (sum, account) => sum + (account.loanAmount ?? 0),
    );
    final totalRemainingPrincipal = loanAccounts.fold(
      0.0,
      (sum, account) => sum + (account.remainingPrincipal ?? 0),
    );
    final totalPaidPrincipal = totalLoanAmount - totalRemainingPrincipal;
    final totalMonthlyPayment = loanAccounts.fold(
      0.0,
      (sum, account) => sum + (account.monthlyPayment ?? 0),
    );

    return {
      'totalLoans': loanAccounts.length,
      'totalLoanAmount': totalLoanAmount,
      'totalRemainingPrincipal': totalRemainingPrincipal,
      'totalPaidPrincipal': totalPaidPrincipal,
      'totalMonthlyPayment': totalMonthlyPayment,
      'averageLoanAmount':
          loanAccounts.isNotEmpty ? totalLoanAmount / loanAccounts.length : 0,
      'averageMonthlyPayment': loanAccounts.isNotEmpty
          ? totalMonthlyPayment / loanAccounts.length
          : 0,
    };
  }

  /// è·å–å³å°†åˆ°æœŸçš„è´·æ¬¾
  List<Account> getUpcomingLoanPayments({int daysAhead = 7}) {
    final now = DateTime.now();
    final upcomingDate = now.add(Duration(days: daysAhead));

    return loanAccounts.where((account) {
      final nextPaymentDate = account.nextPaymentDate;
      return nextPaymentDate != null &&
          nextPaymentDate.isAfter(now) &&
          nextPaymentDate.isBefore(upcomingDate);
    }).toList();
  }

  /// æ‰¹é‡æ›´æ–°è´·æ¬¾çš„å‰©ä½™æœ¬é‡‘
  Future<void> updateAllLoanRemainingPrincipal() async {
    try {
      var hasChanges = false;

      for (var i = 0; i < _accounts.length; i++) {
        final account = _accounts[i];
        if (account.isLoanAccount && account.remainingPrincipal == null) {
          // å¦‚æœå‰©ä½™æœ¬é‡‘ä¸ºç©ºï¼Œä½¿ç”¨è´·æ¬¾æ€»é¢ä½œä¸ºåˆå§‹å€¼
          _accounts[i] = account.copyWith(
            remainingPrincipal: account.loanAmount,
            updateDate: DateTime.now(),
          );
          hasChanges = true;
        }
      }

      if (hasChanges) {
        await _storageService.saveAccounts(_accounts);
        notifyListeners();
      }
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    }
  }

  /// éªŒè¯è´·æ¬¾è®¾ç½®
  LoanValidationResult validateLoanSettings(Account account) {
    final loanCalculationService = LoanCalculationService();
    return loanCalculationService.validateLoanSettings(account);
  }

  @visibleForTesting
  void seedAccountsForTesting(List<Account> accounts) {
    _accounts = List<Account>.from(accounts);
  }
}
